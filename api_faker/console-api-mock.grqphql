type Intention {
  name: String @fake(type:lorem, options:{loremSize:word})
  score: Int
}

type Action {
  source: String @examples(values: ["ai", "helper", "visitor"])
  name: String @fake(type:lorem, options:{loremSize:word})
  status: String @examples(values: ["done", "progress"])
}

type Conversation {
  id: String @fake(type:uuid)
  visitor: String
  bot: String
  client: String
  status: String
  mode: String
  intentions: [Intention]
  actions: [Action]
  messages: [Message]
  # messages will be returned in a MessageFeed object wrapper
  messageFeed(cursor: String): MessageFeed 
  token: String
  createdAt: String
  updatedAt: String
}

type Message {
  id: String
  text: String @fake(type:lorem, options:{loremSize:words})
  source: String @examples(values: ["ai", "helper", "visitor"])
  sourceId: String
  destination: String
  destinationId: String
  bot: String
  client: String
  createdAt: String
  updatedAt: String
}

type MessageFeed {
  # cursor specifies the place in the list where we left off
  cursor: String!
  
  # this is a chunk of messages to be returned
  messages: [Message]!
}

type Bot {
  id: ID @fake(type:uuid)
  name: String @fake(type:word)
  token: String @fake(type:uuid)
  host: String @fake(type:url)
  client: String @fake(type:uuid)
  createdAt: String @fake(type:pastDate,options:{dateFormat:""})
  updatedAt: String @fake(type:pastDate,options:{dateFormat:""})
}

type Knowledge {
  id: String
  raw: String
  text: String
  bot: String
  client: String
  createdAt: String
  updatedAt: String
}

type Suggestion {
  id: String
  text: String
  conversation: String
  delay: Int
}

type Notice {
  id: ID @fake(type:uuid)
}

# For system messages in header
type UserMessage {
  id: ID @fake(type:uuid)
  type: String
  text: String
  action: String
}

type Query {
  conversations(clientId: String, botId: String): [Conversation]
  messages(conversationId: String, clientId: String): [Message]
  bots(clientId: String): [Bot]
  knowledge(clientId: String, botId: String): Knowledge
}

type ConversationEvent {
  id: String @fake(type:uuid)
}

type ConversationEventFeed {
  # cursor specifies the place in the list where we left off
  cursor: String!
  
  # this is a chunk of messages to be returned
  events: [ConversationEvent]!
}

type Mutation {
  updateConversation(conversationId: String!): Conversation
  createMessage(text: String!, conversationId: String!): Message
  createBot(clientId: String!, name: String!, url: String!): Bot
  updateKnowledge(clientId: String!, botId:String!, text: String!): Knowledge
}

type Subscription {
  createConversation(clientId:String): Conversation
  updateConversation(clientId:String): Conversation
  createMessage(clientId:String): Message
  updateMessage(clientId:String): Message
  receiveSuggestion: String
  createSuggestion(conversationId:String): Suggestion
}

schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}
